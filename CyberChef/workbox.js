/**
 * CyberChef - The Cyber Swiss Army Knife
 *
 * @copyright Crown Copyright 2016
 * @license Apache-2.0
 *
 *   Copyright 2016 Crown Copyright
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */!function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=1209)}({1209:function(e,t,r){"use strict";r.r(t);var n={};r.r(n),r.d(n,"DBWrapper",function(){return x}),r.d(n,"WorkboxError",function(){return c}),r.d(n,"assert",function(){return v}),r.d(n,"cacheNames",function(){return l}),r.d(n,"cacheWrapper",function(){return R}),r.d(n,"fetchWrapper",function(){return T}),r.d(n,"getFriendlyURL",function(){return q}),r.d(n,"logger",function(){return b}),r.d(n,"registerQuotaErrorCallback",function(){return j});try{self.workbox.v["workbox:core:3.4.1"]=1}catch(e){}var o={debug:0,log:1,warn:2,error:3,silent:4};var a=(e,...t)=>{let r=e;return t.length>0&&(r+=` :: ${JSON.stringify(t)}`),r};class c extends Error{constructor(e,t){super(a(e,t)),this.name=e,this.details=t}}const i={prefix:"workbox",suffix:self.registration.scope,googleAnalytics:"googleAnalytics",precache:"precache",runtime:"runtime"},s=e=>[i.prefix,e,i.suffix].filter(e=>e.length>0).join("-"),l={updateDetails:e=>{Object.keys(i).forEach(t=>{void 0!==e[t]&&(i[t]=e[t])})},getGoogleAnalyticsName:e=>e||s(i.googleAnalytics),getPrecacheName:e=>e||s(i.precache),getRuntimeName:e=>e||s(i.runtime)},u=/^((?!chrome|android).)*safari/i.test(navigator.userAgent);let d=o.warn;const h=e=>d<=e,f=e=>d=e,g=()=>d,p=o.error,w=function(e,t,r){const n=0===e.indexOf("group")?p:o[e];if(!h(n))return;if(!r||"groupCollapsed"===e&&u)return void console[e](...t);const a=["%cworkbox",`background: ${r}; color: white; padding: 2px 0.5em; `+"border-radius: 0.5em;"];console[e](...a,...t)},y=()=>{h(p)&&console.groupEnd()},b={groupEnd:y,unprefixed:{groupEnd:y}},m={debug:"#7f8c8d",log:"#2ecc71",warn:"#f39c12",error:"#c0392b",groupCollapsed:"#3498db"};Object.keys(m).forEach(e=>((e,t)=>{b[e]=((...r)=>w(e,r,t)),b.unprefixed[e]=((...t)=>w(e,t))})(e,m[e]));const v=null;var _=new class{constructor(){try{self.workbox.v=self.workbox.v||{}}catch(e){}}get cacheNames(){return{googleAnalytics:l.getGoogleAnalyticsName(),precache:l.getPrecacheName(),runtime:l.getRuntimeName()}}setCacheNameDetails(e){l.updateDetails(e)}get logLevel(){return g()}setLogLevel(e){if(e>o.silent||e<o.debug)throw new c("invalid-value",{paramName:"logLevel",validValueDescription:"Please use a value from LOG_LEVELS, i.e 'logLevel = workbox.core.LOG_LEVELS.debug'.",value:e});f(e)}};class x{constructor(e,t,{onupgradeneeded:r,onversionchange:n=this._onversionchange}={}){this._name=e,this._version=t,this._onupgradeneeded=r,this._onversionchange=n,this._db=null}async open(){if(!this._db)return this._db=await new Promise((e,t)=>{let r=!1;setTimeout(()=>{r=!0,t(new Error("The open request was blocked and timed out"))},this.OPEN_TIMEOUT);const n=indexedDB.open(this._name,this._version);n.onerror=(e=>t(n.error)),n.onupgradeneeded=(e=>{r?(n.transaction.abort(),e.target.result.close()):this._onupgradeneeded&&this._onupgradeneeded(e)}),n.onsuccess=(t=>{const n=t.target.result;r?n.close():(n.onversionchange=this._onversionchange,e(n))})}),this}async get(e,...t){return await this._call("get",e,"readonly",...t)}async add(e,...t){return await this._call("add",e,"readwrite",...t)}async put(e,...t){return await this._call("put",e,"readwrite",...t)}async delete(e,...t){await this._call("delete",e,"readwrite",...t)}async deleteDatabase(){this.close(),this._db=null,await new Promise((e,t)=>{const r=indexedDB.deleteDatabase(this._name);r.onerror=(e=>t(e.target.error)),r.onblocked=(()=>t(new Error("Deletion was blocked."))),r.onsuccess=(()=>e())})}async getAll(e,t,r){return"getAll"in IDBObjectStore.prototype?await this._call("getAll",e,"readonly",t,r):await this.getAllMatching(e,{query:t,count:r})}async getAllMatching(e,t={}){return await this.transaction([e],"readonly",(r,n)=>{const o=r[e],a=t.index?o.index(t.index):o,c=[],i=t.query||null,s=t.direction||"next";a.openCursor(i,s).onsuccess=(e=>{const r=e.target.result;if(r){const{primaryKey:e,key:o,value:a}=r;c.push(t.includeKeys?{primaryKey:e,key:o,value:a}:a),t.count&&c.length>=t.count?n(c):r.continue()}else n(c)})})}async transaction(e,t,r){return await this.open(),await new Promise((n,o)=>{const a=this._db.transaction(e,t);a.onerror=(e=>o(e.target.error)),a.onabort=(e=>o(e.target.error)),a.oncomplete=(()=>n());const c={};for(const t of e)c[t]=a.objectStore(t);r(c,e=>n(e),()=>{o(new Error("The transaction was manually aborted")),a.abort()})})}async _call(e,t,r,...n){await this.open();return await this.transaction([t],r,(r,o)=>{r[t][e](...n).onsuccess=(e=>{o(e.target.result)})})}_onversionchange(e){this.close()}close(){this._db&&this._db.close()}}x.prototype.OPEN_TIMEOUT=2e3;var E="cacheDidUpdate",O="cacheWillUpdate",k="cachedResponseWillBeUsed",L="fetchDidFail",N="requestWillFetch",D=(e,t)=>e.filter(e=>t in e);const P=new Set;function j(e){P.add(e)}const q=e=>{const t=new URL(e,location);return t.origin===location.origin?t.pathname:t.href},A=async(e,t,r,n=[])=>{const o=await caches.open(e);let a=await o.match(t,r);for(let o of n)k in o&&(a=await o[k].call(o,{cacheName:e,request:t,matchOptions:r,cachedResponse:a}));return a},S=async(e,t,r)=>{let n=t,o=!1;for(let t of r)if(O in t&&(o=!0,!(n=await t[O].call(t,{request:e,response:n}))))break;return o||(n=n.ok?n:null),n||null},R={put:async(e,t,r,n=[])=>{if(!r)throw new c("cache-put-with-no-response",{url:q(t.url)});let o=await S(t,r,n);if(!o)return;const a=await caches.open(e),i=D(n,E);let s=i.length>0?await A(e,t):null;try{await a.put(t,o)}catch(e){throw"QuotaExceededError"===e.name&&await async function(){for(const e of P)await e()}(),e}for(let r of i)await r[E].call(r,{cacheName:e,request:t,oldResponse:s,newResponse:o})},match:A},T={fetch:async(e,t,r=[],n)=>{if(n){const e=await n;if(e)return e}"string"==typeof e&&(e=new Request(e));const o=D(r,L),a=o.length>0?e.clone():null;try{for(let t of r)N in t&&(e=await t[N].call(t,{request:e.clone()}))}catch(e){throw new c("plugin-error-request-will-fetch",{thrownError:e})}const i=e.clone();try{return await fetch(e,t)}catch(e){for(let t of o)await t[L].call(t,{error:e,originalRequest:a.clone(),request:i.clone()});throw e}}};r.d(t,"LOG_LEVELS",function(){return o}),r.d(t,"_private",function(){return n});t.default=_}});